<templateSet group="C/C++">
  <template name="smac" value="#include &lt;bits/stdc++.h&gt;&#10;&#10;#define fast_input ios_base::sync_with_stdio(false); cin.tie(NULL);&#10;#define endl &quot;\n&quot;&#10;#define allc c.begin(), c.end();&#10;#define allrc c.rbegin(), c.rend();&#10;#define cb c.begin()&#10;#define ce c.end()&#10;#define crb c.rbegin()&#10;#define cre c.rend()&#10;#define Fill(a, b) memset(&amp;a,b,sizeof(a))&#10;#define bline cout &lt;&lt; &quot;\n&quot;&#10;#define REP(i, begin, end) for (__typeof(end) i = (begin) - ((begin) &gt; (end)); i != (end) - ((begin) &gt; (end)); i += 1 - 2 * ((begin) &gt; (end)))&#10;#define deb(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;&#10;using namespace std;&#10;typedef long long int lli;&#10;&#10;#define MAX_SIZE  1000000+7 //1e6+7&#10;#define MOD 1000000000+7 //1e9+7&#10;&#10;template &lt;typename... T&gt;&#10;void read(T&amp;... args){&#10;    ((cin &gt;&gt; args), ...);&#10;};&#10;&#10;template &lt;typename... T&gt;&#10;void write(T&amp;&amp;... args){&#10;    ((cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);&#10;    cout &lt;&lt; &quot;\n&quot;;&#10;};&#10;&#10;&#10;&#10;int main(){&#10;    &#10;    $END$&#10;    &#10;    return 0;&#10;};" description="Initial template" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mgs" value="//Works upon global array a&#10;void merge(int l, int mid, int r){&#10;  int ln = (mid - l + 1);&#10;  int rn = (r - mid);&#10;&#10;  int L[ln], R[rn];&#10;&#10;  //cout &lt;&lt; &quot;LA: &quot;;&#10;  Fr(i, 0, ln){&#10;      L[i] = a[i+l];&#10;    //  cout &lt;&lt; L[i] &lt;&lt; &quot; &quot;;&#10;  };&#10;  //cout &lt;&lt; &quot;\n&quot;;&#10;&#10;    //cout &lt;&lt; &quot;RA: &quot;;&#10;  Fr(i, 0, rn){&#10;      R[i] = a[(mid+1) + i];&#10;      //cout &lt;&lt; R[i] &lt;&lt;  &quot; &quot;;&#10;  };&#10;    //cout &lt;&lt; &quot;\n&quot;;&#10;&#10;  int i = 0, j = 0, k = l;&#10;&#10;  while(i &lt; ln &amp;&amp; j &lt; rn){&#10;    if(L[i] &gt; R[j]){&#10;        cI++;&#10;        a[k] = R[j];&#10;        j++;&#10;    }else {&#10;        a[k] = L[i];&#10;        i++;&#10;    };&#10;    k++;&#10;&#10;  };&#10;&#10;  while(i &lt; ln){&#10;    a[k++] = L[i++];&#10;  };&#10;&#10;  while(j &lt; rn){&#10;      a[k++] = R[j++];&#10;  };&#10;};&#10;&#10;void mergeSort(int l, int r){&#10;&#10;    if(l &lt; r){&#10;        int mid = (l + r)/2;&#10;        mergeSort(l,  mid);&#10;        mergeSort(mid+1, r);&#10;        merge(l, mid, r);&#10;    };&#10;};&#10;" description="Merge Sort" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="tc" value="int tc;&#10;cin &gt;&gt; tc;&#10;&#10;while(tc--){&#10;&#10;    $END$&#10;};" description="Testcase" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bs" value="int bs(int a[], int key, int l, int r){&#10;&#10;    while(l &lt;= r) {&#10;&#10;        int mid = l+ (r-l)/2;&#10;        if(a[mid] == key) return mid;&#10;        else if(a[mid] &lt; key) l = mid + 1;&#10;        else r = mid - 1;&#10;    };&#10;    return -1;&#10;};&#10;" description="Binary Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dsu" value="//dsu&#10;int parent[MAX_SIZE];&#10;&#10;int findSet(int x){&#10;    if(parent[x] &lt; 0) return x;&#10;    else return parent[x] = findSet(parent[x]);&#10;};&#10;&#10;bool union_set(int a, int b){&#10;    int pa = findSet(a);&#10;    int pb = findSet(b);&#10;&#10;    if(pa != pb){&#10;&#10;        if(pa &lt; pb){&#10;            parent[pa] += parent[pb];&#10;            parent[pb] = pa;&#10;        }else {&#10;            parent[pb] += parent[pa];&#10;            parent[pa] = pb;&#10;        }&#10;        return true;&#10;    };&#10;    return false;&#10;};" description="Disjoint Set Union data structure" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="gcd" value="template &lt;class T&gt;&#10;T gcd(T a, T b){&#10;    if(b == 0) return a;&#10;    return gcd(b, a%b);&#10;};&#10;&#10;template &lt;class T&gt;&#10;T lcm(T a, T b){&#10;    return a*b/(gcd(a, b));&#10;};&#10;" description="Greatest common divisor and Least common multiple" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="st" value="// T is the type of input array elements&#10;// V is the type of required aggregate statistic&#10;template&lt;class T, class V&gt;&#10;struct SegmentTreeNode {&#10;    // variables to store aggregate statistics and&#10;    // any other information required to merge these&#10;    // aggregate statistics to form parent nodes&#10;    T prefixMaxSum, suffixMaxSum, maxSum, sum;&#10;&#10;    void assignLeaf(T value) {&#10;        // T is the type of input array element&#10;        // Given the value of an input array element,&#10;        // build aggregate statistics for this leaf node&#10;        prefixMaxSum = suffixMaxSum = maxSum = sum = value;&#10;    }&#10;&#10;    void merge(SegmentTreeNode&amp; left, SegmentTreeNode&amp; right) {&#10;        // merge the aggregate statistics of left and right&#10;        // children to form the aggregate statistics of&#10;        // their parent node&#10;        sum = left.sum + right.sum;&#10;        prefixMaxSum = max(left.prefixMaxSum, left.sum + right.prefixMaxSum);&#10;        suffixMaxSum = max(right.suffixMaxSum, right.sum + left.suffixMaxSum);&#10;        maxSum = max({prefixMaxSum, suffixMaxSum, left.maxSum, right.maxSum, left.suffixMaxSum + right.prefixMaxSum});&#10;    };&#10;&#10;    V getValue() {&#10;        // V is the type of the required aggregate statistic&#10;        // return the value of required aggregate statistic&#10;        // associated with this node&#10;        return maxSum;&#10;    }&#10;};&#10;&#10;// T is the type of input array elements&#10;// V is the type of required aggregate statistic&#10;template&lt;class T, class V&gt;&#10;class SegmentTree {&#10;    SegmentTreeNode&lt;T, V&gt;* nodes;&#10;    int N;&#10;&#10;public:&#10;    SegmentTree(T arr[], int N) {&#10;        this-&gt;N = N;&#10;        nodes = new SegmentTreeNode&lt;T, V&gt;[getSegmentTreeSize(N)];&#10;        buildTree(arr, 1, 0, N-1);&#10;    }&#10;&#10;    ~SegmentTree() {&#10;        delete[] nodes;&#10;    }&#10;&#10;    V getValue(int lo, int hi) {&#10;        SegmentTreeNode&lt;T, V&gt; result = getValue(1, 0, N-1, lo, hi);&#10;        return result.getValue();&#10;    }&#10;&#10;    void update(int index, T value) {&#10;        update(1, 0, N-1, index, value);&#10;    }&#10;&#10;private:&#10;    void buildTree(T arr[], int stIndex, int lo, int hi) {&#10;        if (lo == hi) {&#10;            nodes[stIndex].assignLeaf(arr[lo]);&#10;            return;&#10;        }&#10;&#10;        int left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;&#10;        buildTree(arr, left, lo, mid);&#10;        buildTree(arr, right, mid + 1, hi);&#10;        nodes[stIndex].merge(nodes[left], nodes[right]);&#10;    }&#10;&#10;    SegmentTreeNode&lt;T, V&gt; getValue(int stIndex, int left, int right, int lo, int hi) {&#10;        if (left == lo &amp;&amp; right == hi)&#10;            return nodes[stIndex];&#10;&#10;        int mid = (left + right) / 2;&#10;        if (lo &gt; mid)&#10;            return getValue(2*stIndex+1, mid+1, right, lo, hi);&#10;        if (hi &lt;= mid)&#10;            return getValue(2*stIndex, left, mid, lo, hi);&#10;&#10;        SegmentTreeNode&lt;T, V&gt; leftResult = getValue(2*stIndex, left, mid, lo, mid);&#10;        SegmentTreeNode&lt;T, V&gt; rightResult = getValue(2*stIndex+1, mid+1, right, mid+1, hi);&#10;        SegmentTreeNode&lt;T, V&gt; result;&#10;        result.merge(leftResult, rightResult);&#10;        return result;&#10;    }&#10;&#10;    int getSegmentTreeSize(int N) {&#10;        int size = 1;&#10;        for (; size &lt; N; size &lt;&lt;= 1);&#10;        return size &lt;&lt; 1;&#10;    }&#10;&#10;    void update(int stIndex, int lo, int hi, int index, T value) {&#10;        if (lo == hi) {&#10;            nodes[stIndex].assignLeaf(value);&#10;            return;&#10;        }&#10;&#10;        int left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;&#10;        if (index &lt;= mid)&#10;            update(left, lo, mid, index, value);&#10;        else&#10;            update(right, mid+1, hi, index, value);&#10;&#10;        nodes[stIndex].merge(nodes[left], nodes[right]);&#10;    }&#10;};&#10;&#10;$END$" description="Segment Tree Data structure" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bit1d" value="//Binary Indexed Tree or Fenwick Tree&#10;//For summation function&#10;&#10;//T is type of input Array&#10;template&lt;class T&gt;&#10;class FenwickTree {&#10;    T* nodes;&#10;    int N;&#10;public:&#10;    FenwickTree(T inputArr[], int size){&#10;        this-&gt;N = size+1;&#10;        nodes = new T[this-&gt;N];&#10;        Fr(i, 0, N) nodes[i] = 0;&#10;        buildTree(inputArr);&#10;    };&#10;&#10;    ~FenwickTree(){&#10;        delete[] nodes;&#10;    };&#10;&#10;    T query(int l, int r){&#10;        return getValue(r) - getValue(l-1);&#10;    };&#10;&#10;    T getValue(int i){&#10;        //Here i is zero indexed;&#10;        int p = i+1;&#10;        T ans = 0;&#10;        while(p &gt; 0){&#10;            ans += nodes[p];&#10;            p -= (p &amp; (-p));&#10;        };&#10;        return  ans;&#10;    }&#10;&#10;    void update(int i, T delta){&#10;        //Here i is zero indexed;&#10;        int p = i+1;&#10;        while( p &lt;= this-&gt;N){&#10;            nodes[p] += delta;&#10;            p += (p &amp; (-p));&#10;        };&#10;    };&#10;&#10;private:&#10;    void buildTree(T inputArr[]){&#10;        Fr(i, 0, N-1){&#10;            update(i, inputArr[i]);&#10;        };&#10;    };&#10;};" description="BinaryIndexedTree - 1 d" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="sufa" value="typedef vector&lt;int&gt; vi;&#10;vi suffixArray, lcpArray;&#10;&#10;struct suffix {&#10;    int index, rank[2];&#10;&#10;    bool operator&lt;(const suffix&amp; other){&#10;        return (rank[0] == other.rank[0] ?&#10;        (rank[1] &lt; other.rank[1]):&#10;        (rank[0] &lt; other.rank[0]));&#10;    };&#10;    suffix&amp; operator=(const suffix&amp; other){&#10;        index = other.index;&#10;        rank[0] = other.rank[0];&#10;        rank[1] = other.rank[1];&#10;        return *this;&#10;    };&#10;};&#10;&#10;int getRank(char c){&#10;    //For rank 'space' character is used;&#10;    return c - '#';&#10;};&#10;&#10;&#10;void countSort(suffix suffixes[], int n, int sortByRankIndex){&#10;    int minRank = INT_MAX;&#10;    Fr(i, 0, n){&#10;        if(minRank &gt; suffixes[i].rank[sortByRankIndex])&#10;            minRank = suffixes[i].rank[sortByRankIndex];&#10;    };&#10;&#10;    int maxRank = INT_MIN;&#10;    Fr(i, 0, n){&#10;        if(maxRank &lt; suffixes[i].rank[sortByRankIndex])&#10;            maxRank = suffixes[i].rank[sortByRankIndex];&#10;    };&#10;&#10;    int range = maxRank - minRank + 1;&#10;&#10;    vi count(range, 0);&#10;&#10;    Fr(i, 0, n){&#10;        count[suffixes[i].rank[sortByRankIndex] - minRank]++;&#10;    };&#10;&#10;    Fr(i, 1, range) count[i] += count[i-1];&#10;&#10;    suffix sortedSuffixes[n];&#10;&#10;    for(int i = n-1; i&gt;=0; i--){&#10;        sortedSuffixes[count[suffixes[i].rank[sortByRankIndex] - minRank] - 1] = suffixes[i];&#10;        count[suffixes[i].rank[sortByRankIndex] - minRank]--;&#10;    };&#10;&#10;    Fr(i, 0, n){&#10;        suffixes[i] = sortedSuffixes[i];&#10;    };&#10;};&#10;&#10;void radixSort(suffix suffixes[], int n){&#10;    countSort(suffixes, n, 1);&#10;    countSort(suffixes, n, 0);&#10;};&#10;&#10;//Uses global array suffixArray&#10;void buildSuffixArray(string &amp;s, vi&amp; suffixArr){&#10;    int n = s.size();&#10;    suffixArr.resize(n);&#10;&#10;    suffix suffixes[n];&#10;&#10;    //Initialize all suffixes with index and rank and next rank&#10;    Fr(i, 0, n){&#10;        suffixes[i].index = i;&#10;        suffixes[i].rank[0] = getRank(s[i]);&#10;        suffixes[i].rank[1] = ((i+1) &lt; n ? (getRank(s[i+1])) : -1);&#10;    };&#10;&#10;&#10;    radixSort(suffixes, n);&#10;&#10;    int index[n]; //Need to retrieve indexes of suffixes&#10;&#10;    //Sort remaing of k times;&#10;    for(int k = 4; k &lt; 2 * n; k *= 2){&#10;&#10;        int rank = 0;&#10;        int prevRank = suffixes[0].rank[0];&#10;        suffixes[0].rank[0] = rank;&#10;        index[suffixes[0].index] = 0;&#10;&#10;        //Assingn rank to all suffixes&#10;        Fr(i, 1, n){&#10;&#10;            if(suffixes[i].rank[0] == prevRank &amp;&amp;&#10;                suffixes[i].rank[1] == suffixes[i-1].rank[1]){&#10;                prevRank = suffixes[i].rank[0];&#10;                suffixes[i].rank[0] = rank;&#10;            }else {&#10;                prevRank = suffixes[i].rank[0];&#10;                suffixes[i].rank[0] = ++rank;&#10;            };&#10;&#10;            index[suffixes[i].index] = i;&#10;        };&#10;&#10;&#10;        //Assign nextRank to all suffixes&#10;        Fr(i, 0, n){&#10;            int nextIndex = suffixes[i].index + k / 2;&#10;            suffixes[i].rank[1] = (nextIndex &lt; n ? suffixes[index[nextIndex]].rank[0]: -1);&#10;        };&#10;&#10;        radixSort(suffixes, n);&#10;&#10;    }&#10;&#10;    Fr(i, 0, n){&#10;        suffixArr[i] = suffixes[i].index;&#10;    };&#10;};&#10;&#10;&#10;void buildLCPArray(string&amp; s, vi&amp; suffixArr, vi&amp; lcpArr){&#10;&#10;    int n = s.size();&#10;&#10;    vector&lt;int&gt; rank(n, 0);&#10;&#10;    Fr(i, 0, n) rank[suffixArr[i]] = i;&#10;&#10;    int k = 0;&#10;&#10;    lcpArr.resize(n);&#10;&#10;    Fr(i, 0, n){&#10;&#10;        if(rank[i] == n-1){&#10;            k = 0;&#10;            continue;&#10;        };&#10;&#10;        int j = suffixArr[rank[i] + 1];&#10;&#10;        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k]){&#10;            k++;&#10;        };&#10;        lcpArr[rank[i]] = k;&#10;        if(k) k--;&#10;    };&#10;};&#10;&#10;$END$&#10;" description="Suffix Array - O(nlogn)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mexp" value="#define mtrxSize  2&#10;#define MOD 1000000007 //1e9+7&#10;template &lt;class T&gt;&#10;void matrixProduct(T mtrxA[mtrxSize][mtrxSize], T mtrxB[mtrxSize][mtrxSize]){&#10;    T&amp; a00 = mtrxA[0][0];&#10;    T&amp; a01 = mtrxA[0][1];&#10;    T&amp; a10 = mtrxA[1][0];&#10;    T&amp; a11 = mtrxA[1][1];&#10;&#10;    T&amp; b00 = mtrxB[0][0];&#10;    T&amp; b01 = mtrxB[0][1];&#10;    T&amp; b10 = mtrxB[1][0];&#10;    T&amp; b11 = mtrxB[1][1];&#10;&#10;    T c00 = (((a00 * b00) % MOD) + ((a01 * b10) % MOD)) % MOD;&#10;    T c01 = (((a00 * b01)% MOD) + ((a01 * b11)% MOD))% MOD;&#10;&#10;    T c10 = (((a10 * b00) % MOD) + ((a11 * b10)% MOD))% MOD;&#10;    T c11 = (((a10 * b01)% MOD) + ((a11 * b11)% MOD))% MOD ;&#10;&#10;    mtrxA[0][0] = c00;&#10;    mtrxA[0][1] = c01;&#10;    mtrxA[1][0] = c10;&#10;    mtrxA[1][1] = c11;&#10;&#10;};&#10;&#10;template &lt;class T&gt;&#10;void matrixExpo(T mtrx[mtrxSize][mtrxSize], unsigned int y){&#10;&#10;    lli base[2][2] = {{1, 0}, {0, 1}};&#10;    while(y &gt; 0){&#10;&#10;        if(y &amp; 1){&#10;            matrixProduct(base, mtrx);&#10;        };&#10;&#10;        y &gt;&gt;= 1;&#10;        matrixProduct(mtrx, mtrx);&#10;    };&#10;&#10;    //Copy base to actual mtrx&#10;    Fr(i, 0, 2){&#10;        Fr(j, 0, 2){&#10;            mtrx[i][j] = base[i][j];&#10;        };&#10;    };&#10;&#10;};&#10;&#10;$END$&#10;" description="Matrix Exponentiation With Modulo" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="djk" value="typedef pair&lt;int,int&gt; pii;&#10;typedef vector&lt;int&gt; vi;&#10;&#10;vi adj[MAX_SIZE];&#10;&#10;int djikstra(int s, int d){&#10;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;&#10;&#10;    vector&lt;int&gt; dist(10005, 300000);&#10;    int mark[10005] = {0};&#10;&#10;    pq.push({0, s});&#10;    dist[s] = 0;&#10;&#10;    while(!pq.empty()){&#10;        int u = pq.top().second;&#10;        pq.pop();&#10;&#10;        for(auto x : adj[u]){&#10;&#10;            int w = x.first;&#10;            int v = x.second;&#10;&#10;            if(dist[v] &gt; dist[u] + w &amp;&amp; !mark[v]){&#10;                dist[v] = dist[u] + w;&#10;                pq.push({dist[v], v});&#10;            };&#10;        };&#10;&#10;        mark[u] = 1;&#10;        if(u == d) goto end;&#10;    };&#10;    &#10; $END$" description="Djikstra" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>